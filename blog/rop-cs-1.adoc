= Railroad Oriented Programming in C#: Part 1

// link:/?page=rop-cs-2[Next part]
The term _Railroad Oriented Programming_ was https://fsharpforfunandprofit.com/rop/[popularized by Scott Wlaschin as a term for a certain programming style for handling failure].
In this article series we will look at how we can implement this style of programming in C#.
Let's start by talking about the problems it is trying to solve.

## The problem: implicit function failure

Functions are often designed for the *success path*: the return type only consists of the type the function will return in case of a successful execution.
The following function definition likely wouldn't stand out in an average code base.

[source,cs]
....
User GetUser(string username);
....

This function is supposed to return a User object for the user with the username that is passed into the function.
But sometimes the function isn't able to meet this expectation.

- maybe the user doesn't exist
- maybe because it needs to do a lookup in a datastore and the datastore is temporarily unreachable
- ...

If a function fails, usually one of the following things happens.

. A default value is returned, such as a null reference.
. An exception is thrown.


[pikchr]
....
include::rop.pikchr[]

X0: oval "username" fit
arrow
X1: box "GetUser" fit
arrow 
X2: oval "User" fill lightblue fit
down
arrow dashed from X1.s down
X3: oval "?" fill crimson fit
....

### Problems with using default values for failure
- For *value types* the default value is a valid member of the value space of the type. So there would be no way to distinguish between a success return value and a failure return value in this case.
- For *reference types* the default value (`null`) is not a valid member of the value space of a class in the sense that you can't call the class methods on it. The compiler however treats it as it _were_ a valid member, leading to null-reference bugs. Since the addition of nonnullable reference types in C# 8.0 this set of problems has been diminished a great deal, but a non-negligible pool of pitfalls remains.
- There is no way to return any data along with the failure, such as an error message or some object indicating the reason or nature of the failure.
- There is no way to distinguish between different kinds of failures.

### Problems with throwing exceptions for failure
link:/?page=exceptions-cs[This short article about exceptions goes into the pitfalls of using exceptions.]

### The general problem of implicit failure paths
While the above paragraphs point out some problems with the respective failure-handling strategies, the main problem is this: the *failure path* of `GetUser` is *implicitly defined*.
It is not part of the function signature, and the compiler is not aware of it.
As such, it doesn't get the same amount of attention from the programmer as the success path and is quite frankly too often completely overlooked.

### Solution: explicit failure paths through a `Result` type
The solution is pretty obvious: make the failure path part of the normal return type of the function.

[pikchr]
....
scale = 0.8
linewid = .5cm
lineht = .5cm
boxwid = 3.5cm

X0: oval "username" fit
arrow
X1: box "GetUser" fit

arrow from X1.ne right color lightblue
oval "Success" fit fill lightblue
arrow from X1.se right color orange
oval "Failure" fit fill orange
....

[source,cs]
....
(User OR Error) GetUser(string username);
....

This sounds trivial, so why isn't this done traditionally?
At least part of that has to do with the fact C-like languages do not make it easy to do this.
You would need to have a return type that can be _either_ the success type _or_ the failure type.
In functional programming languages such a construct _does_ exist and is called a https://en.wikipedia.org/wiki/Tagged_union[Discriminated Union].
But C-like languages, including C#, do not have support for such a type.
Luckily C# has had added lots of language features over the years that make it possible to emulate discriminated unions and use them in a relatively convenient and type-safe way.
In the next part of this article series we will have a look at one way of implementing explicit failure in C#: a `Result` type with two subtypes, the `Success` type for the success path and the `Failure` type for the failure path.

### Default values vs the `Failure` type
If performance is critical and you need to avoid as many allocations as possible, then using default values may be a good fit.
However, be aware of the pitfalls listed above.
If performance is not absolutely critical, a default value does not bear any advantages over a proper `Failure` type instance.

### Exception throwing vs the `Failure` type
When writing a function, a good way for deciding whether to propagate a failure by throwing an exception is by asking the following question.

_Should the failure always cause the entire transaction to be aborted in any reasonably conceivable context in which the function might be called_?

If the answer is yes, then it is probably appropriate to handle the failure by throwing an exception.
If the answer is no, then it is probably appropriate to handle the failure by incorporating it in the function return type.
