= Railroad Oriented Programming in C#: Part 3

// link:/?page=rop-cs-2[Previous part]

## Creating Result Instances

[source,cs]
....
Result<User, string> GetUser(string username) {
  var user = Datastore.FindUser(username);
  if (user == null)
    return new Result<User, string>.Failure("User has no email");
  return new Result<User, string>.Success(user);
}
....

[source,cs]
....
Result<User, string> GetUser(string username) {
  var user = Datastore.FindUser(username);
  if (user == null)
    return new Result.Fail("User has no email");
  return new Result.Succeed(user);
}
....

https://tyrrrz.me/blog/return-type-inference[Return type inference]


[source,cs]
....
public abstract class Result<TR, TE> {

  // ...

  public static implicit operator Result<TR, TE>(Result.GenericSuccess<TR> ok) => new Success(ok.Value);
  public static implicit operator Result<TR, TE>(Result.GenericFailure<TE> error) => new Failure(error.Value);
}

public static class Result {
  public static GenericSuccess<TR> Succeed<TR>(TR result) => new(result);
  public static GenericFailure<TE> Fail<TE>(TE error) => new(error);
  public static Result<TR, TE> Succeed<TR, TE>(TR result) => Succeed(result);
  public static Result<TR, TE> Fail<TR, TE>(TE error) => Fail(error);
  public static GenericSuccess<Unit> Succeed() => Succeed(Unit.unit);
  public static GenericFailure<Unit> Fail() => Fail(Unit.unit);

  public readonly struct GenericFailure<T> {
    public T Value { get; }

    public GenericFailure(T value) {
      Value = value;
    }
  }

  public readonly struct GenericSuccess<T> {
    public T Value { get; }

    public GenericSuccess(T value) {
      Value = value;
    }
  }
}
....
