= Railroad Oriented Programming in C#: Part 2

link:/?page=rop-cs-1[Previous part]

link:/?page=rop-cs-3[Next part]

## A Result type supporting the failure path
While C# does not directory support Discriminated Unions, it does support subclassing.
Since a class can have multiple subclasses, and any object is always just one of them, we can use this phenomenon to implement the notion of having two returntypes, one for success result, and one for the failure result.

[source,cs]
....
public abstract class Result {
  public sealed class Success : Result { }
  public sealed class Failure : Result { }
  // Private constructor so we are certain that Success and Failure are the only subclasses
  private Result () { }
}
....

However, this class does not allow us to associate any return data with either the success or the failure result.
We can fix that.

[source,cs]
....
public abstract class Result<TSuccess, TFailure> {
  public sealed class Success : Result<TSuccess, TFailure> {
    public readonly TSuccess SuccessValue;
    public Success(TSuccess result){
      SuccessValue = result;
    }
  }
  public sealed class Failure : Result<TSuccess, TFailure> {
    public readonly TFailure FailureValue;
    public Failure(TFailure error){
      FailureValue = error;
    }
  }
  // Private constructor so we are certain that Success and Failure are the only subclasses
  private Result () { }
}
....

With this in our toolkit we can now implement our `GetEmailAddress` function from earlier with an explicit failure path.

[source,cs]
....
Result<User, string> GetUser(string username) {
  var user = Datastore.FindUser(username);
  if (user == null)
    return new Result<User, string>.Failure("User has no email");
  return new Result<User, string>.Success(user);
}
....

Usage of this function would look something like

[source,cs]
....
var result = GetUser(username);
if (result is Result<User,string>.Success) {
  var user = ((Result<User,string>.Success)result).ResultValue;
  // Do what you wanna do
} else {
  var error = ((Result<User,string>.Failure)result).ErrorValue;
  // Handle the failure appropriately
}
....

As you can see we've achieved an explicit failure path.
When we call `GetUser` we obtain a result object and this encourages us to consider both the success and the failure case.
But the code leaves much to be desired.
Even more so when we need to call more than one function.

[source,cs]
....
Result<string, string> GetEmailAddress(User user);

// ...

var result = GetUser(username);
if (result is Result<User, string>.Success) {
  var user = ((Result<User, string>.Success)result).ResultValue;
  var result2 = GetEmailAddress(user);
  if (result2 is Result<string, string>.Success) {
    var email = ((Result<string, string>.Success)result2).ResultValue;
    // And so on...
  } else {
    var error2 = ((Result<string, string>.Failure)result2).ErrorValue;
    // Handle the failure appropriately
  }
} else {
  var error = ((Result<User, string>.Failure)result).ErrorValue;
  // Handle the failure appropriately
}
....

We would like to

- not have to unwrap the result type by doing a type check + cast
- not have a new nesting level for each subsequent function we call
- not have to handle all failures individually
- not have to specify the whole type when creating a Result instance: `new Result<User, string>.Success()`

## A Fluent Result type

To resolve the complaints about our previous implementation, we'll define an `OnSuccess` function and a `Handle` function.
They will do the unwrapping for us and form a https://en.wikipedia.org/wiki/Fluent_interface[Fluent Interface] and thereby removing the nesting.
Moreover, the OnSuccess function will "shortcircuit" the failure path, such that we only have to handle the failure path once.

[source,cs]
....
public abstract class Result<TS, TF> {
  public abstract Result<TNextR, TF> OnSuccess<TNextR>(Func<TS, Result<TNextR, TF>> onSuccess);
  public abstract TReturn Handle<TReturn>(Func<TS, TReturn> onSuccess, Func<TF, TReturn> onFailure);

  public sealed class Success : Result<TS, TF> {
    public TS SuccessValue { get; }

    public Success(TS result) => SuccessValue = result;
    public override Result<TNextR, TF> OnSuccess<TNextR>(Func<TS, Result<TNextR, TF>> onSuccess)
        => onSuccess(SuccessValue);
    public override TReturn Handle<TReturn>(Func<TS, TReturn> onSuccess, Func<TF, TReturn> onFailure)
        => onSuccess(SuccessValue);
  }

  public sealed class Failure : Result<TS, TF> {
    public TF FailureValue { get; }

    public Failure(TF error) => FailureValue = error;
    public override Result<TNextR, TF> OnSuccess<TNextR>(Func<TS, Result<TNextR, TF>> onSuccess)
        => Result.Fail(FailureValue);
    public override TReturn Handle<TReturn>(Func<TS, TReturn> onSuccess, Func<TF, TReturn> onFailure)
        => onFailure(FailureValue);
  }
  private Result() { }
}
....

Apart from the daunting function signatures, the actual function bodies are trivial.
Yet they suddenly allow us to write very concise code.
Compare the following with what we had in the previous section.

[source,cs]
....
GetUser(username)
  .OnSuccess(GetEmailAddress);
  .Handle(
    emailAddress => ..., // Do your thing
    error => ... // Handle the failure appropriately
  );
....

This style of programming is sometimes referred to as https://fsharpforfunandprofit.com/rop/[_railway oriented programming_], a term first invented by Scott Wlaschin.
Why that is the case is easily demonstrated with some diagrams.
The Result type encapsulates two "paths" or "tracks", the success track and the failure track.

[pikchr]
....
scale = .8

R: oval "Result" fit
arrow from R.n right color lightblue behind R
oval "Success" fit fill lightblue
arrow from R.s right color orange behind R
oval "Failure" fit fill orange
....

And the `OnSuccess` and `Handle` methods form trackpieces.

[pikchr]
....
include::rop.pikchr[]

onSuccess("OnSuccess")
move right
handle("Handle")
....

The railway of the example code would look like

[pikchr]
....
include::rop.pikchr[]

onSuccess("GetUser")
onSuccess("GetEmailAddress")
handle("Handle")
oval "message" fit
....

### Another Example

Suppose now that we needed to write the following function.

[source,cs]
....
/// <returns>Message to be printed on the screen</returns>
string MailMessageToUser(string username, string msg);
....

And suppose that we have the following functions at our disposal.

[source,cs]
....
Result<User, string> GetUser(string username);
Result<string, string> GetEmailAddress(User user);
Result<EmailMessage, string> CreateEmailMessage(string emailAddress, string msg);
Result<Unit, string> SendEmail(EmailMessage email);
....

If you're wondering what that `Unit` type is, it's a replacement for `void`, since we can't put `void` in there.
For more information link:/?page=unit-cs[read my respective article].

Then we could implement the function as follows.

[source,cs]
....
/// <returns>Message to be printed on the screen</returns>
string MailMessageToUser(string username, string msg) {
  return GetUser(username)
    .OnSuccess(GetEmailAddress)
    .OnSuccess(email => CreateEmailMessage(email, msg))
    .OnSuccess(SendEmail)
    .Handle(
      _ => "Email sent",
      error => {
        Log(error);
        return "Email not sent";
      }
    );
}
....

The railway of the example code would look like

[pikchr]
....
include::rop.pikchr[]

onSuccess("GetUser")
onSuccess("GetEmailAddress")
onSuccess("CreateEmailMessage")
onSuccess("SendEmail")
handle("Handle")
oval "message" fit
....

### The OnFailure method

If we have a OnSuccess method, there is no reason why we couldn't have an OnFailure method too.
This would allow us to do operations on the failure track, such as modifying or logging the error, or recovering from the error and get back on the success track.

[pikchr]
....
include::rop.pikchr[]

onFailure("OnFailure")
....

[source,cs]
....
/// <returns>Message to be printed on the screen</returns>
string MailMessageToUser(string username, string msg) {
  return GetUser(username)
    .OnSuccess(GetEmailAddress)
    .OnSuccess(email => CreateEmailMessage(email, msg))
    .OnSuccess(SendEmail)
    .OnFailure<string>(error => {
      LogError(error);
      return Result.Fail(error); // Only log the error and leave the Failure be
    })
    .Handle(
      _ => "Email sent",
      _ => "Email not sent"
    );
}
....

[pikchr]
....
include::rop.pikchr[]

onSuccess("GetUser")
onSuccess("GetEmailAddress")
onSuccess("CreateEmailMessage")
onSuccess("SendEmail")
onFailureF("LogFailure")
handle("Handle")
oval "message" fit
....


## Conclusion

We still need to deal with the awkward construction of Result instances, and we'll do that in the next part.
