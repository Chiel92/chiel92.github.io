= Railroad Oriented Programming in C#: Part 2

## Creating Result Instances

https://tyrrrz.me/blog/return-type-inference[Return type inference]


[source,cs]
....
  public abstract class Result<TResult, TError> {
    public abstract Result<TNextResult, TError> OnSuccess<TNextResult>(Func<TResult, Result<TNextResult, TError>> onSuccess);
    public abstract Result<TResult, TNextError> OnFailure<TNextError>(Func<TError, Result<TResult, TNextError>> onFailure);
    public abstract TReturn Handle<TReturn>(Func<TResult, TReturn> onSuccess, Func<TError, TReturn> onFailure);

    public bool IsSuccess() => this is Success;
    public bool IsFailure() => this is Failure;

    public void HandleVoid(Action<TResult> onSuccess, Action<TError> onFailure) {
      _ = onSuccess ?? throw new ArgumentNullException(nameof(onSuccess));
      _ = onFailure ?? throw new ArgumentNullException(nameof(onFailure));
      _ = Handle(onSuccess.AsFunc(), onFailure.AsFunc());
    }

    public sealed class Success : Result<TResult, TError> {
      public TResult ResultValue { get; }

      internal Success(TResult result) => ResultValue = result;

      public override Result<TNextResult, TError> OnSuccess<TNextResult>(Func<TResult, Result<TNextResult, TError>> onSuccess)
          => onSuccess(ResultValue);

      public override Result<TResult, TNextError> OnFailure<TNextError>(Func<TError, Result<TResult, TNextError>> onFailure)
          => Result.Succeed(ResultValue);

      public override TReturn Handle<TReturn>(Func<TResult, TReturn> onSuccess, Func<TError, TReturn> onFailure)
          => onSuccess(ResultValue);
    }

    public sealed class Failure : Result<TResult, TError> {
      public TError ErrorValue { get; }

      internal Failure(TError error) => ErrorValue = error;

      public override Result<TNextResult, TError> OnSuccess<TNextResult>(Func<TResult, Result<TNextResult, TError>> onSuccess)
          => Result.Fail(ErrorValue);

      public override Result<TResult, TNextError> OnFailure<TNextError>(Func<TError, Result<TResult, TNextError>> onFailure)
          => onFailure(ErrorValue);

      public override TReturn Handle<TReturn>(Func<TResult, TReturn> onSuccess, Func<TError, TReturn> onFailure)
          => onFailure(ErrorValue);
    }

    public static implicit operator Result<TResult, TError>(Result.GenericSuccess<TResult> ok) => new Success(ok.Value);

    public static implicit operator Result<TResult, TError>(Result.GenericFailure<TError> error) => new Failure(error.Value);

    private Result() { }
  }

  /// <summary>
  /// This factory method class makes it possible to create result objects without having to specify the full result type explicitly.
  /// If the generic types cannot be inferred they can also be explicitly passed.
  /// </summary>
  public static class Result {
    public static GenericSuccess<TResult> Succeed<TResult>(TResult result)
        => new(result);

    public static GenericFailure<TError> Fail<TError>(TError error)
        => new(error);

    public static Result<TResult, TError> Succeed<TResult, TError>(TResult result)
        => Succeed(result);

    public static Result<TResult, TError> Fail<TResult, TError>(TError error)
        => Fail(error);

    public static GenericSuccess<Unit> Succeed()
        => Succeed(Unit.unit);

    public static GenericFailure<Unit> Fail()
        => Fail(Unit.unit);

    public readonly struct GenericFailure<T> {
      public T Value { get; }

      public GenericFailure(T value) {
        Value = value;
      }
    }

    public readonly struct GenericSuccess<T> {
      public T Value { get; }

      public GenericSuccess(T value) {
        Value = value;
      }
    }
  }
....
