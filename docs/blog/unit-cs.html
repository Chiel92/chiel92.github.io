<!DOCTYPE html><html lang="en"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>The missing C# built-in type: void</title>


<base target="_self">
</head>
<body class="article">
<div id="header">
<h1>The missing C# built-in type: void</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_the_problem_void_is_not_a_type"><a class="anchor" href="#_the_problem_void_is_not_a_type"></a>The problem: void is not a type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Suppose you wanted to write a <code>Map</code> function for tasks.
The definition is very simple.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">async Task&lt;T2&gt; Map&lt;T1, T2&gt;(Task&lt;T1&gt; task, Func&lt;T1, T2&gt; f) =&gt; f(await task);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then use it as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">Task&lt;int&gt; DoubleIntAsync(Task&lt;int&gt; task)
{
  return Map(task, i =&gt; i * i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a problem however.
We’ve written our <code>Map</code> function to be able to deal with <code>Task&lt;&gt;</code> and <code>Func&lt;&gt;</code>.
But tasks and functions can of course also have void values.
And since the type system doesn’t allow us to simply use <code>Task&lt;void&gt;</code> and <code>Func&lt;void&gt;</code> there exist special void cases of the <code>Task&lt;&gt;</code> and <code>Func&lt;&gt;</code> types, namely <code>Task</code> and <code>Action</code>.
And that disallows us from using our <code>Map</code> for the void cases of these types.
In other words, the following functions won’t compile.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">Task PrintIntAsync(Task&lt;int&gt; task)
{
  return Map(task, Console.WriteLine);
}

Task&lt;string&gt; ReturnTaskFinished(Task task)
{
  return Map(task, () =&gt; "task finished");
}

Task LogTaskFinished(Task task)
{
  return Map(task, () =&gt; Console.WriteLine("task finished"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We would have to write <code>Map</code> overloads to support these void cases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">async Task Map&lt;T1&gt;(Task&lt;T1&gt; task, Action&lt;T1&gt; f) =&gt; f(await task);
async Task Map(Task task, Action f) { await task; f(); }
async Task&lt;T2&gt; Map&lt;T2&gt;(Task task, Func&lt;T2&gt; f) { await task; return f(); }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the function definitions are fairly simple and we only need four of them, but the general problem is bigger.
For each additional type involved that has a void case, the amount of necessary overloads doubles.
And every time we want to write a function that deals with generic types in a generic way (like <code>Map</code>) we encounter this issue and have to write all the overloads.
And don’t forget that the <code>Action</code> and <code>Task</code> void cases also had to be written to work around this issue.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_poor_mans_solution_the_unit_type"><a class="anchor" href="#_a_poor_mans_solution_the_unit_type"></a>A poor man’s solution: the unit type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://en.wikipedia.org/wiki/Unit_type" target="_blank">unit type</a> is nothing but a type with only one value.
Many functional programming languages do not actually support void functions like C# does.
Instead they have a builtin unit type, which is used whenever a function doesn’t return any actual data.
We can create our own C# version of a <code>Unit</code> and use it instead of <code>void</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">public struct Unit : IEquatable&lt;Unit&gt;
{
  public static readonly Unit unit;
  public override bool Equals(object obj) =&gt; obj is Unit;
  public override int GetHashCode() =&gt; 0;
  public static bool operator ==(Unit left, Unit right) =&gt; left.Equals(right);
  public static bool operator !=(Unit left, Unit right) =&gt; !(left == right);
  public bool Equals(Unit other) =&gt; true;
  public override string ToString() =&gt; "()";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we now have a function that is <code>void</code> we can have it return <code>Unit</code> instead, so that it can be used as a <code>Func&lt;Unit&gt;</code> delegate.
Similarly, if we need a <code>Task</code> without a value, we can simply use <code>Task&lt;Unit&gt;</code>.</p>
</div>
<div class="paragraph">
<p>But our code doesn’t live in isolation.
We have to deal with existing code and an existing ecosystem, both of which expose a lot of void oriented types and functions.
Luckily C# supports extension methods, which allow use to deal with this in an acceptable way and convert void cases to their unit counterparts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">using static Unit;

public static class ExtensionMethods
{
  public static async Task&lt;Unit&gt; AsUnitTask(this Task task)
  {
    await task;
    return unit;
  }

  public static Func&lt;TResult, Unit&gt; AsFunc&lt;TResult&gt;(this Action&lt;TResult&gt; action)
  {
    return result =&gt;
    {
      action(result);
      return unit;
    };
  }

  public static Func&lt;Unit, Unit&gt; AsFunc(this Action action)
  {
    return _ =&gt;
    {
      action();
      return unit;
    };
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can rewrite the original snippets as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">Task&lt;int&gt; DoubleIntAsync(Task&lt;int&gt; task)
{
  return Map(task, i =&gt; i * i);
}

Task&lt;Unit&gt; PrintIntAsync(Task&lt;int&gt; task)
{
  // C# does not allow us to call the extension method on the method group directly
  Action&lt;int&gt; a = Console.WriteLine; // First convert the method group to the delegate
  return Map(task, a.AsFunc()); // Now we can call the extension method on the delegate
}

Task&lt;string&gt; ReturnTaskFinished(Task task)
{
  return Map(task.AsUnitTask(), _ =&gt; "task finished");
}

Task&lt;Unit&gt; LogTaskFinished(Task task)
{
  Action a = () =&gt; Console.WriteLine("task finished");
  return Map(task.AsUnitTask(), a.AsFunc());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It may seem that we’ve merely moved the burden from writing <code>Map</code> overloads to writing extension methods.
But that is not the case.
These conversion methods have to be written once per void case type, while the overloads had to be written for <em>each function</em> that uses types with void cases generically, like <code>Map</code>.
And as demonstrated earlier, the number of overloads explodes with the number of types with a void case involved.</p>
</div>
<div class="paragraph">
<p>Yes, it would have been a lot better if <code>void</code> were a valid type.
But having a separate <code>Unit</code> type handy for when you need it is the next best thing.
And when you are writing a generic class, don’t introduce another void case.</p>
</div>
</div>
</div>
</div>

</body></html>