<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Railroad Oriented Programming in C#: Part 2</title>
<link rel="stylesheet" href="/blog/cat.00d63a8d.css">

<base target="_parent">
</head>
<body class="article">
<div id="header">
<h1>Railroad Oriented Programming in C#: Part 2</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In the <a href="/?page=rop-cs-1">previous part</a> we looked at problems with traditional forms of handling failure.
Here we will look at one solution to deal with these problems: a <code>Result</code> type that allows for a success case and a failure case.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_result_type_supporting_the_failure_path">A result type supporting the failure path</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While C# does not directory support Discriminated Unions, it does support subclassing.
Since a class can have multiple subclasses, and any object is always just one of them, we can use this phenomenon to implement the notion of having two return types, one for the success result, and one for the failure result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Result</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Success</span> : <span class="hljs-title">Result</span> { }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Failure</span> : <span class="hljs-title">Result</span> { }
  <span class="hljs-comment">// Private constructor so we are certain that Success and Failure are the only subclasses</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Result</span> ()</span> { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this class does not allow us to associate any return data with either the success or the failure result.
We can fix that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TSuccess</span>, <span class="hljs-title">TFailure</span>&gt; {

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Success</span> : <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TSuccess</span>, <span class="hljs-title">TFailure</span>&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> TSuccess SuccessValue;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Success</span>(<span class="hljs-params">TSuccess result</span>)</span>{
      SuccessValue = result;
    }
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Failure</span> : <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TSuccess</span>, <span class="hljs-title">TFailure</span>&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> TFailure FailureValue;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Failure</span>(<span class="hljs-params">TFailure error</span>)</span>{
      FailureValue = error;
    }
  }

  <span class="hljs-comment">// Private constructor so we are certain that Success and Failure are the only subclasses</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Result</span> ()</span> { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this in our toolkit we can now implement our <code>GetEmailAddress</code> function from earlier with an explicit failure path.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-function">Result&lt;User, <span class="hljs-built_in">string</span>&gt; <span class="hljs-title">GetUser</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> username</span>)</span> {
  <span class="hljs-keyword">var</span> user = Datastore.FindUser(username);
  <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;User, <span class="hljs-built_in">string</span>&gt;.Failure(<span class="hljs-string">&quot;User has no email&quot;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;User, <span class="hljs-built_in">string</span>&gt;.Success(user);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage of this function would look something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-keyword">var</span> result = GetUser(username);
<span class="hljs-keyword">if</span> (result <span class="hljs-keyword">is</span> Result&lt;User,<span class="hljs-built_in">string</span>&gt;.Success) {
  <span class="hljs-keyword">var</span> user = ((Result&lt;User,<span class="hljs-built_in">string</span>&gt;.Success)result).ResultValue;
  <span class="hljs-comment">// Do what you wanna do</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">var</span> error = ((Result&lt;User,<span class="hljs-built_in">string</span>&gt;.Failure)result).ErrorValue;
  <span class="hljs-comment">// Handle the failure appropriately</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see we&#8217;ve achieved an explicit failure path.
When we call <code>GetUser</code> we obtain a result object and this encourages us to consider both the success and the failure case.
But the code leaves much to be desired.
Even more so when we need to call more than one function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-function">Result&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; <span class="hljs-title">GetEmailAddress</span>(<span class="hljs-params">User user</span>)</span>;

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">var</span> result = GetUser(username);
<span class="hljs-keyword">if</span> (result <span class="hljs-keyword">is</span> Result&lt;User, <span class="hljs-built_in">string</span>&gt;.Success) {
  <span class="hljs-keyword">var</span> user = ((Result&lt;User, <span class="hljs-built_in">string</span>&gt;.Success)result).ResultValue;
  <span class="hljs-keyword">var</span> result2 = GetEmailAddress(user);
  <span class="hljs-keyword">if</span> (result2 <span class="hljs-keyword">is</span> Result&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;.Success) {
    <span class="hljs-keyword">var</span> email = ((Result&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;.Success)result2).ResultValue;
    <span class="hljs-comment">// And so on...</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> error2 = ((Result&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;.Failure)result2).ErrorValue;
    <span class="hljs-comment">// Handle the failure appropriately</span>
  }
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">var</span> error = ((Result&lt;User, <span class="hljs-built_in">string</span>&gt;.Failure)result).ErrorValue;
  <span class="hljs-comment">// Handle the failure appropriately</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We would like to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>not have to unwrap the <code>Result</code> instance by doing a type check + cast</p>
</li>
<li>
<p>not have a new nesting level for each subsequent function we call</p>
</li>
<li>
<p>not have to handle all failures individually</p>
</li>
<li>
<p>not have to specify the whole type when creating a <code>Result</code> instance: <code>new Result&lt;User, string&gt;.Success()</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_a_fluent_result_type">A fluent result type</h3>
<div class="paragraph">
<p>To resolve the complaints about our previous implementation, we&#8217;ll define an <code>OnSuccess</code> function and a <code>Handle</code> function.
They will do the unwrapping for us and form a <a href="https://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a> and thereby removing the nesting.
Moreover, the OnSuccess function will "shortcircuit" the failure path, such that we only have to handle the failure path once.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TSuccess</span>, <span class="hljs-title">TFailure</span>&gt;</span> {

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TNextSuccess</span>, <span class="hljs-title">TFailure</span>&gt; <span class="hljs-title">OnSuccess</span>&lt;<span class="hljs-title">TNextSuccess</span>&gt;(<span class="hljs-params">
    Func&lt;TSuccess, Result&lt;TNextSuccess, TFailure&gt;&gt; onSuccess</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> TReturn <span class="hljs-title">Handle</span>&lt;<span class="hljs-title">TReturn</span>&gt;(<span class="hljs-params">Func&lt;TSuccess, TReturn&gt; onSuccess, Func&lt;TFailure, TReturn&gt; onFailure</span>)</span>;

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Success</span> : <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TSuccess</span>, <span class="hljs-title">TFailure</span>&gt; {
    <span class="hljs-keyword">public</span> TSuccess SuccessValue { <span class="hljs-keyword">get</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Success</span>(<span class="hljs-params">TSuccess result</span>)</span> =&gt; SuccessValue = result;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TNextSuccess</span>, <span class="hljs-title">TFailure</span>&gt; <span class="hljs-title">OnSuccess</span>&lt;<span class="hljs-title">TNextSuccess</span>&gt;(<span class="hljs-params">
      Func&lt;TSuccess, Result&lt;TNextSuccess, TFailure&gt;&gt; onSuccess</span>)</span>
        =&gt; onSuccess(SuccessValue);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> TReturn <span class="hljs-title">Handle</span>&lt;<span class="hljs-title">TReturn</span>&gt;(<span class="hljs-params">Func&lt;TSuccess, TReturn&gt; onSuccess, Func&lt;TFailure, TReturn&gt; onFailure</span>)</span>
        =&gt; onSuccess(SuccessValue);
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Failure</span> : <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TSuccess</span>, <span class="hljs-title">TFailure</span>&gt; {
    <span class="hljs-keyword">public</span> TFailure FailureValue { <span class="hljs-keyword">get</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Failure</span>(<span class="hljs-params">TFailure error</span>)</span> =&gt; FailureValue = error;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TNextSuccess</span>, <span class="hljs-title">TFailure</span>&gt; <span class="hljs-title">OnSuccess</span>&lt;<span class="hljs-title">TNextSuccess</span>&gt;(<span class="hljs-params">
      Func&lt;TSuccess, Result&lt;TNextSuccess, TFailure&gt;&gt; onSuccess</span>)</span>
        =&gt; Result.Fail(FailureValue);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> TReturn <span class="hljs-title">Handle</span>&lt;<span class="hljs-title">TReturn</span>&gt;(<span class="hljs-params">Func&lt;TSuccess, TReturn&gt; onSuccess, Func&lt;TFailure, TReturn&gt; onFailure</span>)</span>
        =&gt; onFailure(FailureValue);
  }

  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Result</span>()</span> { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Apart from the daunting function signatures, the actual function bodies are trivial.
Yet they suddenly allow us to write very concise code.
Compare the following with what we had in the previous section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">GetUser(username)
  .OnSuccess(GetEmailAddress);
  .Handle(
    emailAddress =&gt; ..., <span class="hljs-comment">// Do your thing</span>
    error =&gt; ... <span class="hljs-comment">// Handle the failure appropriately</span>
  );</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we visualize the code flow above in a diagram, it becomes clear why this style of programming is sometimes referred to as <em>railway oriented programming</em>.
The <code>Result</code> type encapsulates two "paths" or "tracks", the success track and the failure track.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<span class="alt">Diagram</span>
</div>
</div>
<div class="paragraph">
<p>And the <code>OnSuccess</code> and <code>Handle</code> methods form trackpieces.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<span class="alt">Diagram</span>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<span class="alt">Diagram</span>
</div>
</div>
<div class="paragraph">
<p>The railway of the example code would look like</p>
</div>
<div class="imageblock kroki">
<div class="content">
<span class="alt">Diagram</span>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_another_example">Another example</h3>
<div class="paragraph">
<p>Suppose now that we needed to write the following function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Message to be printed on the screen<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">MailMessageToUser</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> msg</span>)</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And suppose that we have the following functions at our disposal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-function">Result&lt;User, <span class="hljs-built_in">string</span>&gt; <span class="hljs-title">GetUser</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> username</span>)</span>;
<span class="hljs-function">Result&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; <span class="hljs-title">GetEmailAddress</span>(<span class="hljs-params">User user</span>)</span>;
<span class="hljs-function">Result&lt;EmailMessage, <span class="hljs-built_in">string</span>&gt; <span class="hljs-title">CreateEmailMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> emailAddress, <span class="hljs-built_in">string</span> msg</span>)</span>;
<span class="hljs-function">Result&lt;Unit, <span class="hljs-built_in">string</span>&gt; <span class="hljs-title">SendEmail</span>(<span class="hljs-params">EmailMessage email</span>)</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;re wondering what that <code>Unit</code> type is, it&#8217;s a replacement for <code>void</code>, since we can&#8217;t put <code>void</code> in there.
For more information refer to <a href="/?page=unit-cs">The missing C# built-in type: void</a>.</p>
</div>
<div class="paragraph">
<p>Then we could implement the function as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Message to be printed on the screen<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">MailMessageToUser</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> msg</span>)</span> {
  <span class="hljs-keyword">return</span> GetUser(username)
    .OnSuccess(GetEmailAddress)
    .OnSuccess(email =&gt; CreateEmailMessage(email, msg))
    .OnSuccess(SendEmail)
    .Handle(
      _ =&gt; <span class="hljs-string">&quot;Email sent&quot;</span>,
      error =&gt; {
        Log(error);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Email not sent&quot;</span>;
      }
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The railway of the example code would look like</p>
</div>
<div class="imageblock kroki">
<div class="content">
<span class="alt">Diagram</span>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_void_handlers">Void handlers</h3>
<div class="paragraph">
<p>If we would rather handle the end result without returning anything, e.g. using void methods only, we would need a variant of <code>Handle</code> for that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">TSuccess</span>, <span class="hljs-title">TFailure</span>&gt; {

  <span class="hljs-comment">// ...</span>

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleVoid</span>(<span class="hljs-params">Action&lt;TResult&gt; onSuccess, Action&lt;TError&gt; onFailure</span>)</span> {
    _ = onSuccess ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(onSuccess));
    _ = onFailure ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(onFailure));

    _ = Handle(onSuccess.AsFunc(), onFailure.AsFunc());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we could use it as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Message to be printed on the screen<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">MailMessageToUser</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> msg</span>)</span> {
  <span class="hljs-keyword">return</span> GetUser(username)
    .OnSuccess(GetEmailAddress)
    .OnSuccess(email =&gt; CreateEmailMessage(email, msg))
    .OnSuccess(SendEmail)
    .HandleVoid(
      _ =&gt; {
        Console.WriteLine(<span class="hljs-string">&quot;Email sent&quot;</span>);
      },
      error =&gt; {
        Log(error);
        Console.WriteLine(<span class="hljs-string">&quot;Email not sent&quot;</span>);
      }
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the implementation of <code>AsFunc</code>, refer to <a href="/?page=unit-cs">The missing C# built-in type: void</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_onfailure_method">The OnFailure method</h3>
<div class="paragraph">
<p>If we have a OnSuccess method, there is no reason why we couldn&#8217;t have an OnFailure method too.
This would allow us to do operations on the failure track, such as modifying the error, or recovering from the error and get back on the success track.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<span class="alt">Diagram</span>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Message to be printed on the screen<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">MailMessageToUser</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> msg</span>)</span> {
  <span class="hljs-keyword">return</span> GetUser(username)
    .OnSuccess(GetEmailAddress)
    .OnSuccess(email =&gt; CreateEmailMessage(email, msg))
    .OnSuccess(SendEmail)
    .OnFailure(error =&gt; <span class="hljs-keyword">new</span> Result&lt;Unit, <span class="hljs-built_in">string</span>&gt;.Failure(<span class="hljs-string">&quot;An error occurred: &quot;</span> + error))
    .Handle(
      _ =&gt; <span class="hljs-string">&quot;Email sent&quot;</span>,
      error =&gt; {
        Log(error);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Email not sent&quot;</span>;
      }
    );
}</code></pre>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<span class="alt">Diagram</span>
</div>
</div>
<div class="paragraph">
<p>We still need to deal with the awkward construction of <code>Result</code> instances, and we&#8217;ll do that in the <a href="/?page=rop-cs-3">next part</a>.</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>