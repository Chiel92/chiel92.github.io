<!DOCTYPE html><html lang="en"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Railroad Oriented Programming in C#: Part 2</title>


<base target="_self">
</head>
<body class="article">
<div id="header">
<h1>Railroad Oriented Programming in C#: Part 2</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In the <a href="/?page=rop-cs-1">previous part</a> we looked at problems with traditional forms of handling failure.
Here we will look at one solution to deal with these problems: a <code>Result</code> type that allows for a success case and a failure case.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_result_type_supporting_the_failure_path"><a class="anchor" href="#_a_result_type_supporting_the_failure_path"></a>A result type supporting the failure path</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While C# does not directory support Discriminated Unions, it does support subclassing.
Since a class can have multiple subclasses, and any object is always just one of them, we can use this phenomenon to implement the notion of having two return types, one for the success result, and one for the failure result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">public abstract class Result {
  public sealed class Success : Result { }
  public sealed class Failure : Result { }
  // Private constructor so we are certain that Success and Failure are the only subclasses
  private Result () { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this class does not allow us to associate any return data with either the success or the failure result.
We can fix that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">public abstract class Result&lt;TSuccess, TFailure&gt; {

  public sealed class Success : Result&lt;TSuccess, TFailure&gt; {
    public readonly TSuccess SuccessValue;
    public Success(TSuccess result){
      SuccessValue = result;
    }
  }

  public sealed class Failure : Result&lt;TSuccess, TFailure&gt; {
    public readonly TFailure FailureValue;
    public Failure(TFailure error){
      FailureValue = error;
    }
  }

  // Private constructor so we are certain that Success and Failure are the only subclasses
  private Result () { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this in our toolkit we can now implement our <code>GetEmailAddress</code> function from earlier with an explicit failure path.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">Result&lt;User, string&gt; GetUser(string username) {
  var user = Datastore.FindUser(username);
  if (user == null)
    return new Result&lt;User, string&gt;.Failure("User has no email");
  return new Result&lt;User, string&gt;.Success(user);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage of this function would look something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">var result = GetUser(username);
if (result is Result&lt;User,string&gt;.Success) {
  var user = ((Result&lt;User,string&gt;.Success)result).ResultValue;
  // Do what you wanna do
} else {
  var error = ((Result&lt;User,string&gt;.Failure)result).ErrorValue;
  // Handle the failure appropriately
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see we’ve achieved an explicit failure path.
When we call <code>GetUser</code> we obtain a result object and this encourages us to consider both the success and the failure case.
But the code leaves much to be desired.
Even more so when we need to call more than one function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">Result&lt;string, string&gt; GetEmailAddress(User user);

// ...

var result = GetUser(username);
if (result is Result&lt;User, string&gt;.Success) {
  var user = ((Result&lt;User, string&gt;.Success)result).ResultValue;
  var result2 = GetEmailAddress(user);
  if (result2 is Result&lt;string, string&gt;.Success) {
    var email = ((Result&lt;string, string&gt;.Success)result2).ResultValue;
    // And so on...
  } else {
    var error2 = ((Result&lt;string, string&gt;.Failure)result2).ErrorValue;
    // Handle the failure appropriately
  }
} else {
  var error = ((Result&lt;User, string&gt;.Failure)result).ErrorValue;
  // Handle the failure appropriately
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We would like to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>not have to unwrap the <code>Result</code> instance by doing a type check + cast</p>
</li>
<li>
<p>not have a new nesting level for each subsequent function we call</p>
</li>
<li>
<p>not have to handle all failures individually</p>
</li>
<li>
<p>not have to specify the whole type when creating a <code>Result</code> instance: <code>new Result&lt;User, string&gt;.Success()</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_a_fluent_result_type"><a class="anchor" href="#_a_fluent_result_type"></a>A fluent result type</h3>
<div class="paragraph">
<p>To resolve the complaints about our previous implementation, we’ll define an <code>OnSuccess</code> function and a <code>Handle</code> function.
They will do the unwrapping for us and form a <a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank">Fluent Interface</a> and thereby removing the nesting.
Moreover, the OnSuccess function will "shortcircuit" the failure path, such that we only have to handle the failure path once.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">public abstract class Result&lt;TSuccess, TFailure&gt; {

  public abstract Result&lt;TNextSuccess, TFailure&gt; OnSuccess&lt;TNextSuccess&gt;(
    Func&lt;TSuccess, Result&lt;TNextSuccess, TFailure&gt;&gt; onSuccess);
  public abstract TReturn Handle&lt;TReturn&gt;(Func&lt;TSuccess, TReturn&gt; onSuccess, Func&lt;TFailure, TReturn&gt; onFailure);

  public sealed class Success : Result&lt;TSuccess, TFailure&gt; {
    public TSuccess SuccessValue { get; }

    public Success(TSuccess result) =&gt; SuccessValue = result;

    public override Result&lt;TNextSuccess, TFailure&gt; OnSuccess&lt;TNextSuccess&gt;(
      Func&lt;TSuccess, Result&lt;TNextSuccess, TFailure&gt;&gt; onSuccess)
        =&gt; onSuccess(SuccessValue);

    public override TReturn Handle&lt;TReturn&gt;(Func&lt;TSuccess, TReturn&gt; onSuccess, Func&lt;TFailure, TReturn&gt; onFailure)
        =&gt; onSuccess(SuccessValue);
  }

  public sealed class Failure : Result&lt;TSuccess, TFailure&gt; {
    public TFailure FailureValue { get; }

    public Failure(TFailure error) =&gt; FailureValue = error;

    public override Result&lt;TNextSuccess, TFailure&gt; OnSuccess&lt;TNextSuccess&gt;(
      Func&lt;TSuccess, Result&lt;TNextSuccess, TFailure&gt;&gt; onSuccess)
        =&gt; Result.Fail(FailureValue);

    public override TReturn Handle&lt;TReturn&gt;(Func&lt;TSuccess, TReturn&gt; onSuccess, Func&lt;TFailure, TReturn&gt; onFailure)
        =&gt; onFailure(FailureValue);
  }

  private Result() { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Apart from the daunting function signatures, the actual function bodies are trivial.
Yet they suddenly allow us to write very concise code.
Compare the following with what we had in the previous section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">GetUser(username)
  .OnSuccess(GetEmailAddress);
  .Handle(
    emailAddress =&gt; ..., // Do your thing
    error =&gt; ... // Handle the failure appropriately
  );</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we visualize the code flow above in a diagram, it becomes clear why this style of programming is sometimes referred to as <em>railway oriented programming</em>.
The <code>Result</code> type encapsulates two "paths" or "tracks", the success track and the failure track.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>scale = .8

R: oval "Result" fit
arrow from R.n right color lightblue behind R
oval "Success" fit fill lightblue
arrow from R.s right color orange behind R
oval "Failure" fit fill orange</pre>
</div>
</div>
<div class="paragraph">
<p>And the <code>OnSuccess</code> and <code>Handle</code> methods form trackpieces.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>scale = .8
linerad = .1
linewid = .2
lineht = .22

define dashes {
  line color lightblue dashed .03
  move from last line.w down lineht 
  right
  line color orange dashed .03
  move up lineht; right
}

define newline {
  dashes
  move left until even with (0,0) then down then right
  dashes
}

define startResult {
  S0: arrow
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  FR: oval $3 fit
  F: line right lineht/2 color orange behind FR

  S1: line from SF.start right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR
}

define onSuccess {
  S0: arrow color lightblue
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  S1: line from B.e right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR

  move from S0.start down lineht
  F0: line right until even with S2.end color orange
  move up lineht; right
}

define onFailure {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  SF: line right linerad then up then right until even with lineht e of B.e color lightblue behind B
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define onFailureF {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define handle {
  S: arrow right color lightblue
  move from S.start down lineht
  F: arrow right color orange
  box $1 fit with west at 1/2 between S.end and F.end
  line right
  oval $2 fit
  arrow right
}

onSuccess("OnSuccess", "SuccessValue")</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>scale = .8
linerad = .1
linewid = .2
lineht = .22

define dashes {
  line color lightblue dashed .03
  move from last line.w down lineht 
  right
  line color orange dashed .03
  move up lineht; right
}

define newline {
  dashes
  move left until even with (0,0) then down then right
  dashes
}

define startResult {
  S0: arrow
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  FR: oval $3 fit
  F: line right lineht/2 color orange behind FR

  S1: line from SF.start right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR
}

define onSuccess {
  S0: arrow color lightblue
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  S1: line from B.e right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR

  move from S0.start down lineht
  F0: line right until even with S2.end color orange
  move up lineht; right
}

define onFailure {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  SF: line right linerad then up then right until even with lineht e of B.e color lightblue behind B
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define onFailureF {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define handle {
  S: arrow right color lightblue
  move from S.start down lineht
  F: arrow right color orange
  box $1 fit with west at 1/2 between S.end and F.end
  line right
  oval $2 fit
  arrow right
}

handle("Handle", "EndValue")</pre>
</div>
</div>
<div class="paragraph">
<p>The railway of the example code would look like</p>
</div>
<div class="literalblock">
<div class="content">
<pre>scale = .8
linerad = .1
linewid = .2
lineht = .22

define dashes {
  line color lightblue dashed .03
  move from last line.w down lineht 
  right
  line color orange dashed .03
  move up lineht; right
}

define newline {
  dashes
  move left until even with (0,0) then down then right
  dashes
}

define startResult {
  S0: arrow
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  FR: oval $3 fit
  F: line right lineht/2 color orange behind FR

  S1: line from SF.start right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR
}

define onSuccess {
  S0: arrow color lightblue
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  S1: line from B.e right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR

  move from S0.start down lineht
  F0: line right until even with S2.end color orange
  move up lineht; right
}

define onFailure {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  SF: line right linerad then up then right until even with lineht e of B.e color lightblue behind B
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define onFailureF {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define handle {
  S: arrow right color lightblue
  move from S.start down lineht
  F: arrow right color orange
  box $1 fit with west at 1/2 between S.end and F.end
  line right
  oval $2 fit
  arrow right
}

startResult("GetUser","User","string")
onSuccess("GetEmailAddress","string")
handle("Handle","string")</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_another_example"><a class="anchor" href="#_another_example"></a>Another example</h3>
<div class="paragraph">
<p>Suppose now that we needed to write the following function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">/// &lt;returns&gt;Message to be printed on the screen&lt;/returns&gt;
string MailMessageToUser(string username, string msg);</code></pre>
</div>
</div>
<div class="paragraph">
<p>And suppose that we have the following functions at our disposal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">Result&lt;User, string&gt; GetUser(string username);
Result&lt;string, string&gt; GetEmailAddress(User user);
Result&lt;EmailMessage, string&gt; CreateEmailMessage(string emailAddress, string msg);
Result&lt;Unit, string&gt; SendEmail(EmailMessage email);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you’re wondering what that <code>Unit</code> type is, it’s a replacement for <code>void</code>, since we can’t put <code>void</code> in there.
For more information refer to <a href="/?page=unit-cs">The missing C# built-in type: void</a>.</p>
</div>
<div class="paragraph">
<p>Then we could implement the function as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">/// &lt;returns&gt;Message to be printed on the screen&lt;/returns&gt;
string MailMessageToUser(string username, string msg) {
  return GetUser(username)
    .OnSuccess(GetEmailAddress)
    .OnSuccess(email =&gt; CreateEmailMessage(email, msg))
    .OnSuccess(SendEmail)
    .Handle(
      _ =&gt; "Email sent",
      error =&gt; {
        Log(error);
        return "Email not sent";
      }
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The railway of the example code would look like</p>
</div>
<div class="literalblock">
<div class="content">
<pre>scale = .8
linerad = .1
linewid = .2
lineht = .22

define dashes {
  line color lightblue dashed .03
  move from last line.w down lineht 
  right
  line color orange dashed .03
  move up lineht; right
}

define newline {
  dashes
  move left until even with (0,0) then down then right
  dashes
}

define startResult {
  S0: arrow
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  FR: oval $3 fit
  F: line right lineht/2 color orange behind FR

  S1: line from SF.start right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR
}

define onSuccess {
  S0: arrow color lightblue
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  S1: line from B.e right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR

  move from S0.start down lineht
  F0: line right until even with S2.end color orange
  move up lineht; right
}

define onFailure {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  SF: line right linerad then up then right until even with lineht e of B.e color lightblue behind B
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define onFailureF {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define handle {
  S: arrow right color lightblue
  move from S.start down lineht
  F: arrow right color orange
  box $1 fit with west at 1/2 between S.end and F.end
  line right
  oval $2 fit
  arrow right
}

startResult("GetUser","User","string")
onSuccess("GetEmailAddress","string")
newline
onSuccess("CreateEmailMessage","EmailMessage")
onSuccess("SendEmail","Unit")
handle("Handle","string")</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_void_handlers"><a class="anchor" href="#_void_handlers"></a>Void handlers</h3>
<div class="paragraph">
<p>If we would rather handle the end result without returning anything, e.g. using void methods only, we would need a variant of <code>Handle</code> for that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">public abstract class Result&lt;TSuccess, TFailure&gt; {

  // ...

  public void HandleVoid(Action&lt;TResult&gt; onSuccess, Action&lt;TError&gt; onFailure) {
    _ = onSuccess ?? throw new ArgumentNullException(nameof(onSuccess));
    _ = onFailure ?? throw new ArgumentNullException(nameof(onFailure));

    _ = Handle(onSuccess.AsFunc(), onFailure.AsFunc());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we could use it as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">/// &lt;returns&gt;Message to be printed on the screen&lt;/returns&gt;
string MailMessageToUser(string username, string msg) {
  return GetUser(username)
    .OnSuccess(GetEmailAddress)
    .OnSuccess(email =&gt; CreateEmailMessage(email, msg))
    .OnSuccess(SendEmail)
    .HandleVoid(
      _ =&gt; {
        Console.WriteLine("Email sent");
      },
      error =&gt; {
        Log(error);
        Console.WriteLine("Email not sent");
      }
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the implementation of <code>AsFunc</code>, refer to <a href="/?page=unit-cs">The missing C# built-in type: void</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_onfailure_method"><a class="anchor" href="#_the_onfailure_method"></a>The OnFailure method</h3>
<div class="paragraph">
<p>If we have a OnSuccess method, there is no reason why we couldn’t have an OnFailure method too.
This would allow us to do operations on the failure track, such as modifying the error, or recovering from the error and get back on the success track.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>scale = .8
linerad = .1
linewid = .2
lineht = .22

define dashes {
  line color lightblue dashed .03
  move from last line.w down lineht 
  right
  line color orange dashed .03
  move up lineht; right
}

define newline {
  dashes
  move left until even with (0,0) then down then right
  dashes
}

define startResult {
  S0: arrow
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  FR: oval $3 fit
  F: line right lineht/2 color orange behind FR

  S1: line from SF.start right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR
}

define onSuccess {
  S0: arrow color lightblue
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  S1: line from B.e right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR

  move from S0.start down lineht
  F0: line right until even with S2.end color orange
  move up lineht; right
}

define onFailure {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  SF: line right linerad then up then right until even with lineht e of B.e color lightblue behind B
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define onFailureF {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define handle {
  S: arrow right color lightblue
  move from S.start down lineht
  F: arrow right color orange
  box $1 fit with west at 1/2 between S.end and F.end
  line right
  oval $2 fit
  arrow right
}

onFailure("OnFailure","ErrorValue")</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">/// &lt;returns&gt;Message to be printed on the screen&lt;/returns&gt;
string MailMessageToUser(string username, string msg) {
  return GetUser(username)
    .OnSuccess(GetEmailAddress)
    .OnSuccess(email =&gt; CreateEmailMessage(email, msg))
    .OnSuccess(SendEmail)
    .OnFailure(error =&gt; new Result&lt;Unit, string&gt;.Failure("An error occurred: " + error))
    .Handle(
      _ =&gt; "Email sent",
      error =&gt; {
        Log(error);
        return "Email not sent";
      }
    );
}</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>scale = .8
linerad = .1
linewid = .2
lineht = .22

define dashes {
  line color lightblue dashed .03
  move from last line.w down lineht 
  right
  line color orange dashed .03
  move up lineht; right
}

define newline {
  dashes
  move left until even with (0,0) then down then right
  dashes
}

define startResult {
  S0: arrow
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  FR: oval $3 fit
  F: line right lineht/2 color orange behind FR

  S1: line from SF.start right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR
}

define onSuccess {
  S0: arrow color lightblue
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  S1: line from B.e right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR

  move from S0.start down lineht
  F0: line right until even with S2.end color orange
  move up lineht; right
}

define onFailure {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  SF: line right linerad then up then right until even with lineht e of B.e color lightblue behind B
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define onFailureF {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define handle {
  S: arrow right color lightblue
  move from S.start down lineht
  F: arrow right color orange
  box $1 fit with west at 1/2 between S.end and F.end
  line right
  oval $2 fit
  arrow right
}

startResult("GetUser","User","string")
onSuccess("GetEmailAddress","string")
onSuccess("CreateEmailMessage","EmailMessage")
newline
onSuccess("SendEmail","Unit")
onFailureF("TransformError","string")
handle("Handle","string")</pre>
</div>
</div>
<div class="paragraph">
<p>We still need to deal with the awkward construction of <code>Result</code> instances, and we’ll do that in the <a href="/?page=rop-cs-3">next part</a>.</p>
</div>
</div>
</div>
</div>
</div>

</body></html>