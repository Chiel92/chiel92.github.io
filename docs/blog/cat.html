<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 2.0.17"><title>Category Theory</title><link rel="stylesheet" href="/blog/exceptions-cs.6a7a6e14.css"><base target="_parent"></head><body class="article"> <div id="header"> <h1>Category Theory</h1> </div> <div id="content"> <div class="sect1"> <h2 id="_definitions">1. Definitions</h2> <div class="sectionbody"> <div class="sect2"> <h3 id="def-category">1.1. Definition Category</h3> <div class="paragraph"> <p>A <strong>category</strong> C consists of:</p> </div> <div class="ulist"> <ul> <li> <p>A collection of objects, denoted by Obj<sub>C</sub>.</p> </li> <li> <p>A collection of morphisms (arrows) between objects, denoted by Mor<sub>C</sub>.</p> </li> <li> <p>A composition operation, denoted by ∘ : Mor<sub>C</sub> × Mor<sub>C</sub> → Mor<sub>C</sub>.</p> </li> <li> <p>For each object a in Obj<sub>C</sub>, an identity morphism id<sub>a</sub> in Mor<sub>C</sub>.</p> </li> </ul> </div> <div class="paragraph"> <p>The composition operation satisfies the following two axioms:</p> </div> <div class="lowerroman olist"> <ol class="lowerroman" type="i"> <li> <p>(Associativity) For any morphisms f, g, and h in Mor<sub>C</sub>, (f ∘ g) ∘ h = f ∘ (g ∘ h).</p> </li> <li> <p>(Identity) For any object a in Obj<sub>C</sub> and any morphism f in Mor<sub>C</sub>, f ∘ id<sub>a</sub> = f and id<sub>a</sub> ∘ f = f.</p> </li> </ol> </div> </div> <div class="sect2"> <h3 id="def-functor">1.2. Definition Functor</h3> <div class="paragraph"> <p>Given two categories C and D, a <strong>functor</strong> F : C → D consists of:</p> </div> <div class="ulist"> <ul> <li> <p>A function F : Obj<sub>C</sub> → Obj<sub>D</sub></p> </li> <li> <p>A function F<sub>map</sub> : Mor<sub>C</sub> → Mor<sub>D</sub></p> </li> </ul> </div> <div class="paragraph"> <p>These functions must satisfy the following two conditions:</p> </div> <div class="lowerroman olist"> <ol class="lowerroman" type="i"> <li> <p>For any two morphisms f and g in Mor<sub>C</sub>, F<sub>map</sub> (f ∘ g) = F<sub>map</sub> f ∘ F<sub>map</sub> g.</p> </li> <li> <p>For any object a in Obj<sub>C</sub>, F<sub>map</sub> id<sub>a</sub> = id<sub>F a</sub>.</p> </li> </ol> </div> <div class="paragraph"> <p>If C and D are the same category, F is called an <strong>endofunctor</strong>.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="_examples">2. Examples</h2> <div class="sectionbody"> <div class="sect2"> <h3 id="ex-fp">2.1. The FP Category</h3> <div class="paragraph"> <p>The category FP, with objects being types and morphisms being functions, forms a category. Composition of two functions f and g in Mor<sub>FP</sub> is defined as <code>(f ∘ g) x = f (g x)</code>. For any object a in Obj<sub>FP</sub>, id<sub>a</sub> is defined as the function <code>id<sub>a</sub> x = x</code>.</p> </div> <div class="paragraph"> <p><em>Proof.</em></p> </div> <div class="paragraph"> <p>To prove the equivalence of two functions, it suffices to show that they yield the same output for the same input.</p> </div> <div class="lowerroman olist"> <ol class="lowerroman" type="i"> <li> <p>(Associativity) For any morphisms f, g, and h in Mor<sub>FP</sub>, (f ∘ g) ∘ h = f ∘ (g ∘ h).</p> </li> </ol> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-hs" data-lang="hs">((f ∘ g) ∘ h) x
  = (f ∘ g) (h x)
  = f (g (h x))

<span class="hljs-title">f</span> ∘ (g ∘ h) x
  = f ((g ∘ h) x)
  = f (g (h x))</code></pre> </div> </div> <div class="lowerroman olist"> <ol class="lowerroman" type="i" start="2"> <li> <p>(Identity) For any object a in Obj<sub>FP</sub> and any morphism f in Mor<sub>FP</sub>, f ∘ id<sub>a</sub> = f and id<sub>a</sub> ∘ f = f.</p> </li> </ol> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-hs" data-lang="hs">(f ∘ id<sub>a</sub>) x
  = f (id<sub>a</sub> x) <span class="hljs-comment">-- definition composition</span>
  = f x         <span class="hljs-comment">-- definition id<sub>a</sub></span>

(id<sub>a</sub> ∘ f) x
  = id<sub>a</sub> (f x) <span class="hljs-comment">-- definition composition</span>
  = f x         <span class="hljs-comment">-- definition id<sub>a</sub></span></code></pre> </div> </div> <div class="paragraph"> <p>∎</p> </div> </div> <div class="sect2"> <h3 id="ex-list-functor">2.2. The List Functor</h3> <div class="paragraph"> <p>The <code>List</code> type constructor forms an endofunctor in the category FP.</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-hs" data-lang="hs"><span class="hljs-comment">-- List : Obj<sub>T</sub> → Obj<sub>T</sub></span>
<span class="hljs-type">List</span> a = <span class="hljs-type">Nil</span> | <span class="hljs-type">Cons</span> a (<span class="hljs-type">List</span> a)
<span class="hljs-comment">-- List<sub>map</sub> : Mor<sub>T</sub> → Mor<sub>T</sub></span>
<span class="hljs-type">List</span><sub>map</sub> :: (a → b) → (<span class="hljs-type">List</span> a → <span class="hljs-type">List</span> b)
<span class="hljs-type">List</span><sub>map</sub> f <span class="hljs-type">Nil</span> = <span class="hljs-type">Nil</span>
<span class="hljs-type">List</span><sub>map</sub> f (<span class="hljs-type">Cons</span> x xs) = <span class="hljs-type">Cons</span> (f x) (<span class="hljs-type">List</span><sub>map</sub> f xs)</code></pre> </div> </div> <div class="paragraph"> <p><em>Proof.</em></p> </div> <div class="lowerroman olist"> <ol class="lowerroman" type="i"> <li> <p>For any two morphisms f and g in Mor<sub>T</sub>, List<sub>map</sub> (f ∘ g) = List<sub>map</sub> f ∘ List<sub>map</sub> g.</p> </li> </ol> </div> <div class="paragraph"> <p>We prove that these two expressions are the same for all possible inputs, namely Nil and Cons x xs.</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-hs" data-lang="hs"><span class="hljs-type">List</span><sub>map</sub> (f ∘ g) <span class="hljs-type">Nil</span> = <span class="hljs-type">Nil</span>

(<span class="hljs-type">List</span><sub>map</sub> f ∘ <span class="hljs-type">List</span><sub>map</sub> g) <span class="hljs-type">Nil</span>
  = <span class="hljs-type">List</span><sub>map</sub> f (<span class="hljs-type">List</span><sub>map</sub> g <span class="hljs-type">Nil</span>)    <span class="hljs-comment">-- definition composition</span>
  = <span class="hljs-type">List</span><sub>map</sub> f <span class="hljs-type">Nil</span>    <span class="hljs-comment">-- definition List<sub>map</sub></span>
  = <span class="hljs-type">Nil</span>    <span class="hljs-comment">-- definition List<sub>map</sub></span></code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-hs" data-lang="hs"><span class="hljs-type">List</span><sub>map</sub> (f ∘ g) (<span class="hljs-type">Cons</span> x xs)
  = <span class="hljs-type">Cons</span> ((f ∘ g) x) (<span class="hljs-type">List</span><sub>map</sub> (f ∘ g) xs)    <span class="hljs-comment">-- definition List<sub>map</sub></span>

(<span class="hljs-type">List</span><sub>map</sub> f ∘ <span class="hljs-type">List</span><sub>map</sub> g) (<span class="hljs-type">Cons</span> x xs)
  = <span class="hljs-type">List</span><sub>map</sub> f (<span class="hljs-type">List</span><sub>map</sub> g (<span class="hljs-type">Cons</span> x xs))    <span class="hljs-comment">-- definition composition</span>
  = <span class="hljs-type">List</span><sub>map</sub> f (<span class="hljs-type">Cons</span> (g x) (<span class="hljs-type">List</span><sub>map</sub> g xs))    <span class="hljs-comment">-- definition List<sub>map</sub></span>
  = <span class="hljs-type">Cons</span> (f (g x)) (<span class="hljs-type">List</span><sub>map</sub> f (<span class="hljs-type">List</span><sub>map</sub> g xs))    <span class="hljs-comment">-- definition List<sub>map</sub></span>
  = <span class="hljs-type">Cons</span> ((f ∘ g) x) ((<span class="hljs-type">List</span><sub>map</sub> f ∘ <span class="hljs-type">List</span><sub>map</sub> g) xs)    <span class="hljs-comment">-- definition composition</span></code></pre> </div> </div> <div class="paragraph"> <p>All we have left to prove is that List<sub>map</sub> (f ∘ g) xs = (List<sub>map</sub> f ∘ List<sub>map</sub> g) xs. Because it is true for xs = Nil, it follows by induction that the statement is true for all xs.</p> </div> <div class="lowerroman olist"> <ol class="lowerroman" type="i" start="2"> <li> <p>For any object a in Obj<sub>T</sub>, List<sub>map</sub> id<sub>a</sub> = id<sub>List a</sub>.</p> </li> </ol> </div> <div class="paragraph"> <p>We prove that these two expressions are the same for all possible inputs, namely Nil and Cons x xs.</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-hs" data-lang="hs"><span class="hljs-type">List</span><sub>map</sub> id<sub>a</sub> <span class="hljs-type">Nil</span> = <span class="hljs-type">Nil</span>    <span class="hljs-comment">-- definition List<sub>map</sub></span>

<span class="hljs-title">id</span><sub>list a</sub> <span class="hljs-type">Nil</span> = <span class="hljs-type">Nil</span>    <span class="hljs-comment">-- definition id<sub>list a</sub></span></code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-hs" data-lang="hs"><span class="hljs-type">List</span><sub>map</sub> id<sub>a</sub> (<span class="hljs-type">Cons</span> x xs)
  = <span class="hljs-type">Cons</span> (id<sub>a</sub> x) (<span class="hljs-type">List</span><sub>map</sub> id<sub>a</sub> xs)    <span class="hljs-comment">-- definition List<sub>map</sub></span>
  = <span class="hljs-type">Cons</span> x (<span class="hljs-type">List</span><sub>map</sub> id<sub>a</sub> xs)    <span class="hljs-comment">-- definition id<sub>a</sub></span>

<span class="hljs-title">id</span><sub>list a</sub> (<span class="hljs-type">Cons</span> x xs) = <span class="hljs-type">Cons</span> x xs    <span class="hljs-comment">-- definition id<sub>list a</sub></span></code></pre> </div> </div> <div class="paragraph"> <p>All we have left to prove is that List<sub>map</sub> id<sub>a</sub> xs = xs. Because it is true for xs = Nil, it follows by induction that the statement is true for all xs.</p> </div> <div class="paragraph"> <p>∎</p> </div> </div> </div> </div> </div> </body></html>