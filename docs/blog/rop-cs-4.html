<!DOCTYPE html><html lang="en"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Railroad Oriented Programming in C#: Part 4</title>


<base target="_self">
</head>
<body class="article">
<div id="header">
<h1>Railroad Oriented Programming in C#: Part 4</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In the <a href="/?page=rop-cs-3">previous part</a> we looked at how we could construct <code>Result</code> instances more easily.
In this part we will look at slightly more complex railway tracks and wrap up the series.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_subtracks_and_failure_recovery"><a class="anchor" href="#_subtracks_and_failure_recovery"></a>Subtracks and failure recovery</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Railroad Oriented Programming is not limited to having a single straight railroad.
As we compose functions together writing our program, a more complex railroad system will evolve, reflecting our program flow.
It is highly recommended that one does not put too much complex railroad logic in a single function, but it is perfectly possible to construct subtracks within a railroad function.
Let’s give an example that demonstrates having a subtrack and performing a failure recovery.</p>
</div>
<div class="paragraph">
<p>Suppose that now the <code>SendEmail</code> function does not return a <code>string</code> on failure, but some failure object like an <code>Exception</code> instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">Result&lt;Unit, Exception&gt; SendEmail(EmailMessage email, MailServer server);</code></pre>
</div>
</div>
<div class="paragraph">
<p>We could then inspect this failure object and decide how to handle it based on the kind of failure.
Suppose we want to send an email to the server, but we have a fallback server in case the first server fails.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">/// &lt;returns&gt;Message to be printed on the screen&lt;/returns&gt;
string MailMessageToUser(string username, string msg, MailServer server1, MailServer server2) {
  return GetUser(username)
    .OnSuccess(GetEmailAddress)
    .OnSuccess(emailAddress =&gt; CreateEmailMessage(emailAddress, msg))
    .OnSuccess(email =&gt; SendEmail(email, server1)
      .OnFailure(ex =&gt; ex switch {
        ServerNotFoundException =&gt;
          // Attempt server1. We don't need to inspect the second exception,
          // and can directly transform it to an error string using OnFailure.
          SendEmail(email, server2).OnFailure&lt;string&gt;(ex =&gt; Result.Fail(ex.Message)),
        _ =&gt; Result.Fail(ex.Message)
      })
    )
    .Handle(
      _ =&gt; "Email sent",
      error =&gt; {
        LogError(error);
        return "Email not sent";
      }
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we attempt to defer our email to a second mail server when the first server appears unreachable.
The function <code>MailMessageToUser</code> having two mail servers as parameters is a little odd, and probably not how we would want to do it in real life.
But it demonstrates having subtracks and failure recovery very well in the context of our email example.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>scale = .8
linerad = .1
linewid = .2
lineht = .22

define dashes {
  line color lightblue dashed .03
  move from last line.w down lineht 
  right
  line color orange dashed .03
  move up lineht; right
}

define newline {
  dashes
  move left until even with (0,0) then down then right
  dashes
}

define startResult {
  S0: arrow
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  FR: oval $3 fit
  F: line right lineht/2 color orange behind FR

  S1: line from SF.start right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR
}

define onSuccess {
  S0: arrow color lightblue
  B: box $1 fit
  SF: line right linerad then down then right until even with lineht e of B.e color orange behind B
  S1: line from B.e right color lightblue behind B
  SR: oval $2 fit
  S2: line right lineht/2 color lightblue behind SR

  move from S0.start down lineht
  F0: line right until even with S2.end color orange
  move up lineht; right
}

define onFailure {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  SF: line right linerad then up then right until even with lineht e of B.e color lightblue behind B
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define onFailureF {
  move down lineht; right

  S0: arrow color orange
  B: box $1 fit
  S1: line from B.e right color orange behind B
  SR: oval $2 fit
  S2: line right lineht/2 color orange behind SR

  move from S0.start up lineht
  F0: line right until even with S2.end color lightblue
}

define handle {
  S: arrow right color lightblue
  move from S.start down lineht
  F: arrow right color orange
  box $1 fit with west at 1/2 between S.end and F.end
  line right
  oval $2 fit
  arrow right
}

startResult("GetUser","User","string")
onSuccess("GetEmailAddress","string")
onSuccess("CreateEmailMessage","MailMessage")
newline

S0: arrow color lightblue
B1: box "SendEmail" fit
line right linewid color orange behind B1
EX: oval "Exception" fit
arrow right linewid color orange behind B1
B2: box "SendEmail2" fit
line right linewid*2 color lightblue behind B2
oval "Unit" fit
E: line right color lightblue behind last oval

line behind B1 from B1.e right linerad then up then right until even with B2.e then right linerad*2 then down then right color lightblue
line behind EX from EX.e right linerad then down then right color orange

move from S0.start down lineht
line right until even with E.end color orange

line from B2.e right linerad then down then right color orange behind B2

move to E.end

handle("Handle","string")</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_asynchronous_programming"><a class="anchor" href="#_asynchronous_programming"></a>Asynchronous programming</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Using the <code>Result</code> type for asynchronous programming is perfectly possible, but again comes with a few hacks to account for some C# compiler limitations.
Maybe I’ll write another article about that some time.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here follows the code for the <code>Result</code> type we’ve produced in this article series.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cs" data-lang="cs">  public abstract class Result&lt;TSuccess, TFailure&gt; {

    public abstract Result&lt;TNextSuccess, TFailure&gt; OnSuccess&lt;TNextSuccess&gt;(
      Func&lt;TSuccess, Result&lt;TNextSuccess, TFailure&gt;&gt; onSuccess);
    public abstract Result&lt;TSuccess, TNextFailure&gt; OnFailure&lt;TNextFailure&gt;(
      Func&lt;TFailure, Result&lt;TSuccess, TNextFailure&gt;&gt; onFailure);
    /// &lt;summary&gt;
    /// Prefer &lt;see cref="OnSuccess"&gt; and &lt;see cref="OnFailure"&gt; over this method for returning Result types.
    /// &lt;/summary&gt;
    public abstract TReturn Handle&lt;TReturn&gt;(Func&lt;TSuccess, TReturn&gt; onSuccess, Func&lt;TFailure, TReturn&gt; onFailure);

    public bool IsSuccess() =&gt; this is Success;
    public bool IsFailure() =&gt; this is Failure;

    #region Void overloads (Because void is not an actual type in .NET)

    public void HandleVoid(Action&lt;TSuccess&gt; onSuccess, Action&lt;TFailure&gt; onFailure) {
      _ = onSuccess ?? throw new ArgumentNullException(nameof(onSuccess));
      _ = onFailure ?? throw new ArgumentNullException(nameof(onFailure));

      _ = Handle(onSuccess.AsFunc(), onFailure.AsFunc());
    }

    #endregion

    public sealed class Success : Result&lt;TSuccess, TFailure&gt; {
      public TSuccess ResultValue { get; }

      public Success(TSuccess result) =&gt; ResultValue = result;

      public override Result&lt;TNextSuccess, TFailure&gt; OnSuccess&lt;TNextSuccess&gt;(
        Func&lt;TSuccess, Result&lt;TNextSuccess, TFailure&gt;&gt; onSuccess)
          =&gt; onSuccess(ResultValue);

      public override Result&lt;TSuccess, TNextFailure&gt; OnFailure&lt;TNextFailure&gt;(
        Func&lt;TFailure, Result&lt;TSuccess, TNextFailure&gt;&gt; onFailure)
          =&gt; Result.Succeed(ResultValue);

      public override TReturn Handle&lt;TReturn&gt;(Func&lt;TSuccess, TReturn&gt; onSuccess, Func&lt;TFailure, TReturn&gt; onFailure)
          =&gt; onSuccess(ResultValue);
    }

    public sealed class Failure : Result&lt;TSuccess, TFailure&gt; {
      public TFailure ErrorValue { get; }

      public Failure(TFailure error) =&gt; ErrorValue = error;

      public override Result&lt;TNextSuccess, TFailure&gt; OnSuccess&lt;TNextSuccess&gt;(
        Func&lt;TSuccess, Result&lt;TNextSuccess, TFailure&gt;&gt; onSuccess)
          =&gt; Result.Fail(ErrorValue);

      public override Result&lt;TSuccess, TNextFailure&gt; OnFailure&lt;TNextFailure&gt;(
        Func&lt;TFailure, Result&lt;TSuccess, TNextFailure&gt;&gt; onFailure)
          =&gt; onFailure(ErrorValue);

      public override TReturn Handle&lt;TReturn&gt;(Func&lt;TSuccess, TReturn&gt; onSuccess, Func&lt;TFailure, TReturn&gt; onFailure)
          =&gt; onFailure(ErrorValue);
    }

    public static implicit operator Result&lt;TSuccess, TFailure&gt;(Result.GenericSuccess&lt;TSuccess&gt; success)
        =&gt; new Success(success.Value);

    public static implicit operator Result&lt;TSuccess, TFailure&gt;(Result.GenericFailure&lt;TFailure&gt; failure)
        =&gt; new Failure(failure.Value);

    private Result() { }
  }

  /// &lt;summary&gt;
  /// This factory method class makes it possible to create result objects without
  /// having to specify the full result type explicitly.
  /// If the generic types cannot be inferred they can also be explicitly passed.
  /// &lt;/summary&gt;
  public static class Result {
    public static GenericSuccess&lt;TSuccess&gt; Succeed&lt;TSuccess&gt;(TSuccess result)
        =&gt; new(result);

    public static GenericFailure&lt;TFailure&gt; Fail&lt;TFailure&gt;(TFailure error)
        =&gt; new(error);

    public static Result&lt;TSuccess, TFailure&gt; Succeed&lt;TSuccess, TFailure&gt;(TSuccess result)
        =&gt; Succeed(result);

    public static Result&lt;TSuccess, TFailure&gt; Fail&lt;TSuccess, TFailure&gt;(TFailure error)
        =&gt; Fail(error);

    public static GenericSuccess&lt;Unit&gt; Succeed()
        =&gt; Succeed(Unit.unit);

    public static GenericFailure&lt;Unit&gt; Fail()
        =&gt; Fail(Unit.unit);

    public readonly struct GenericFailure&lt;T&gt; {
      public T Value { get; }

      public GenericFailure(T value) {
        Value = value;
      }
    }

    public readonly struct GenericSuccess&lt;T&gt; {
      public T Value { get; }

      public GenericSuccess(T value) {
        Value = value;
      }
    }
  }</code></pre>
</div>
</div>
</div>
</div>
</div>

</body></html>