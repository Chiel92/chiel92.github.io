<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 2.0.15"><title>On exception throwing and catching in C#</title><link rel="stylesheet" href="/blog/unit-cs.6720997f.css"><base target="_parent"><script type="text/javascript" src="https://livejs.com/live.js"></script></head><body class="article"> <div id="header"> <h1>On exception throwing and catching in C#</h1> </div> <div id="content"> <div class="sect1"> <h2 id="_problems_with_throwing_exceptions_for_failure">Problems with throwing exceptions for failure</h2> <div class="sectionbody"> <div class="ulist"> <ul> <li> <p>Exceptions are not part of the function signature. As such a caller of a function does not know which exceptions to catch unless he reads all the code that is possibly hit by the function, assuming that he even has access to it.</p> </li> <li> <p>In well-defined and well-maintained APIs the list of possible exceptions a function can throw is stated in the documentation. But the compiler is not aware of this. So:</p> <div class="ulist"> <ul> <li> <p>The user of the API can easily overlook exceptions and get away without compiler warnings.</p> </li> <li> <p>If the API changes over time and adds more exceptions, the user will not be notified of this by the compiler.</p> </li> <li> <p>Most functions are not part of a well-defined API. And even seemingly well-defined/documented APIs are not always documented exhaustively, especially as they change over time.</p> </li> </ul> </div> </li> <li> <p>Throwing is slow and using throw/catch for control flow just kills performance.</p> </li> <li> <p>When using a debugger, the debugger halts on most exceptions. Specifying which exceptions to halt on is a lot of work if you throw a lot of exceptions for control flow.</p> </li> <li> <p>Frequent try/catch blocks are verbose, make the actual intention of the code much less clear and are bound to lead to making mistakes of forgetting to catch all the right things in all the right places.</p> </li> </ul> </div> </div> </div> <div class="sect1"> <h2 id="_exceptions_are_a_part_of_life">Exceptions are a part of life</h2> <div class="sectionbody"> <div class="paragraph"> <p>Making a failure path part of the function return type is neat, but it does not mean that there are no exceptional situations for which the exception throwing mechanism is a good fit. To give an extreme example, almost any function can <em>in theory</em> encounter an <code>OutOfMemoryException</code> while doing an allocation. Or any function could <em>in theory</em> trigger a bug somewhere causing a <code>NullReferenceException</code> to be thrown. Exceptions are a fact of life, and we should be prepared to deal with them. It would make no sense to have the returntype of each function indicate that it could return with a null reference failure in the way we suggested above. These cases are really exceptions which are <strong>unexpected</strong>. There is often no proper way to handle them other than to cancel the whole "operation", log the error and present the user with an appropriate error, indicating that something went completely sideways. So how should we deal with that in our code?</p> </div> <div class="arabic olist"> <ol class="arabic"> <li> <p>In a complex application there is no way of telling whether you have caught all exceptions you want to catch.</p> </li> <li> <p>You probably don&#8217;t want to crash your application or present your user an exception with a callstack.</p> </li> <li> <p>In that case you should split up your application into <a href="https://en.wikipedia.org/wiki/Fail-fast">fail-fast</a> modules.</p> <div class="ulist"> <ul> <li> <p>A piece of code is a valid fail-fast module if its abortion does not harm the health of the rest of the application.</p> </li> <li> <p>An fail-fast module may contain other fail-fast modules.</p> </li> </ul> </div> </li> <li> <p>Place a try-catch-all construction at the top of each fail-fast module, such that it is guaranteed that each exception will not propagate beyond the fail-fast module in which it occurs. Make sure the exception is properly handled and logged.</p> </li> <li> <p>Never place a try-catch construction at a point in your program where it incorrectly may prevent an fail-fast module to be aborted.</p> </li> <li> <p>The more fail-fast modules you have and the smaller they are, the more stable your application is expected to be.</p> </li> <li> <p>So, now we&#8217;ve achieved that an uncaught exception only affects its containing fail-fast module. However, we still don&#8217;t know if we&#8217;ve missed any exceptions that should <em>not</em> cause the fail-fast module to be aborted.</p> </li> <li> <p>Study any 3rd party APIs well for exceptions that could have been missed.</p> </li> <li> <p>Don&#8217;t throw exceptions yourself if it shouldn&#8217;t abort the fail-fast module. Instead make the corresponding failure part of the normal code path <a href="/?page=rop-cs-1">using a <code>Result</code> type</a>.</p> </li> </ol> </div> <div class="paragraph"> <p>For example, in a web application each request should at least be a separate fail-fast module because a failure to handle a request should not bring the web application down or influence other requests in any other way. Some programs (perhaps a CLI) may consist of a single fail-fast module.</p> </div> </div> </div> </div> <div id="footer"> <div id="footer-text"> Last updated 2021-08-02 13:52:39 +0200 </div> </div> </body></html>