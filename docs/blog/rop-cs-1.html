<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 2.0.15"><title>Railroad Oriented Programming in C#: Part 1</title><link rel="stylesheet" href="/blog/unit-cs.6720997f.css"><base target="_parent"><script type="text/javascript" src="https://livejs.com/live.js"></script></head><body class="article"> <div id="header"> <h1>Railroad Oriented Programming in C#: Part 1</h1> </div> <div id="content"> <div class="sect1"> <h2 id="_the_problem_implicit_function_failure">The problem: implicit function failure</h2> <div class="sectionbody"> <div class="paragraph"> <p>Functions are often designed for the <strong>success path</strong>: the return type only consists of the type the function will return in case of a successful execution. The following function definition likely wouldn&#8217;t stand out in an average code base.</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-cs" data-lang="cs"><span class="hljs-function">User <span class="hljs-title">GetUser</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> username</span>)</span>;</code></pre> </div> </div> <div class="paragraph"> <p>This function is supposed to return a User object for the user with the username that is passed into the function. But sometimes the function isn&#8217;t able to meet this expectation.</p> </div> <div class="ulist"> <ul> <li> <p>maybe the user doesn&#8217;t exist</p> </li> <li> <p>maybe because it needs to do a lookup in a datastore and the datastore is temporarily unreachable</p> </li> <li> <p>&#8230;&#8203;</p> </li> </ul> </div> <div class="paragraph"> <p>If a function fails, usually one of the following things happens.</p> </div> <div class="arabic olist"> <ol class="arabic"> <li> <p>A default value is returned, such as a null reference.</p> </li> <li> <p>An exception is thrown.</p> </li> </ol> </div> <div class="imageblock kroki"> <div class="content"> <svg xmlns="http://www.w3.org/2000/svg" class="pikchr" width="229" height="74" viewbox="0 0 287.827 93.6"> <path d="M17,32L81,32A15 15 0 0 0 96 17A15 15 0 0 0 81 2L17,2A15 15 0 0 0 2 17A15 15 0 0 0 17 32Z" style="fill:none;stroke-width:2.16;stroke:#000"></path> <text x="49" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">username</text> <polygon points="125,17 113,21 113,12" style="fill:#000"></polygon> <path d="M96,17L119,17" style="fill:none;stroke-width:2.16;stroke:#000"></path> <path d="M125,32L205,32L205,2L125,2Z" style="fill:none;stroke-width:2.16;stroke:#000"></path> <text x="165" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">GetUser</text> <polygon points="234,17 222,21 222,12" style="fill:#000"></polygon> <path d="M205,17L228,17" style="fill:none;stroke-width:2.16;stroke:#000"></path> <path d="M249,32L270,32A15 15 0 0 0 285 17A15 15 0 0 0 270 2L249,2A15 15 0 0 0 234 17A15 15 0 0 0 249 32Z" style="fill:#add8e6;stroke-width:2.16;stroke:#000"></path> <text x="259" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">User</text> <polygon points="165,61 161,49 169,49" style="fill:#000"></polygon> <path d="M165,32L165,55" style="fill:none;stroke-width:2.16;stroke:#000;stroke-dasharray:7.2,7.2"></path> <path d="M165,91A15 15 0 0 0 180 76A15 15 0 0 0 165 61A15 15 0 0 0 150 76A15 15 0 0 0 165 91Z" style="fill:#dc143c;stroke-width:2.16;stroke:#000"></path> <text x="165" y="76" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">?</text> </svg> </div> </div> <div class="sect2"> <h3 id="_problems_with_using_default_values_for_failure">Problems with using default values for failure</h3> <div class="ulist"> <ul> <li> <p>For <strong>value types</strong> the default value is a valid member of the value space of the type. So there would be no way to distinguish between a success return value and a failure return value in this case.</p> </li> <li> <p>For <strong>reference types</strong> the default value (<code>null</code>) is not a valid member of the value space. The compiler however treats it as it <em>were</em> a valid member, leading to null-reference bugs. Since the addition of nonnullable reference types in C# 8.0 this set of problems has been diminished a great deal, but a non-negligible pool of pitfalls remains.</p> </li> <li> <p>There is no way to return any data along with the failure, such as an error message or some object indicating the reason or nature of the failure.</p> </li> <li> <p>There is no way to distinguish between different kinds of failures.</p> </li> </ul> </div> </div> <div class="sect2"> <h3 id="_problems_with_throwing_exceptions_for_failure">Problems with throwing exceptions for failure</h3> <div class="ulist"> <ul> <li> <p>Exceptions are not part of the function signature. As such a caller of a function does not know which exceptions to catch unless he reads all the code that is possibly hit by the function, assuming that he even has access to it.</p> </li> <li> <p>In well-defined and well-maintained APIs the list of possible exceptions a function can throw is stated in the documentation. But the compiler is not aware of this. So:</p> <div class="ulist"> <ul> <li> <p>The user of the API can easily overlook exceptions and get away without compiler warnings.</p> </li> <li> <p>If the API changes over time and adds more exceptions, the user will not be notified of this by the compiler.</p> </li> <li> <p>Most functions are not part of a well-defined API.</p> </li> </ul> </div> </li> </ul> </div> </div> <div class="sect2"> <h3 id="_the_general_problem_of_implicit_failure_paths">The general problem of implicit failure paths</h3> <div class="paragraph"> <p>While the above paragraphs point out some problems with the respective failure-handling strategies, the main problem is this: the <strong>failure path</strong> of <code>GetUser</code> is <strong>implicitly defined</strong>. It is not part of the function signature, and the compiler is not aware of it. As such, it doesn&#8217;t get the same amount of attention from the programmer as the success path and is quite frankly too often completely overlooked.</p> </div> </div> <div class="sect2"> <h3 id="_solution_explicit_failure_paths_through_a_result_type">Solution: explicit failure paths through a <code>Result</code> type</h3> <div class="paragraph"> <p>The solution is pretty obvious: make the failure path part of the normal return type of the function.</p> </div> <div class="imageblock kroki"> <div class="content"> <svg xmlns="http://www.w3.org/2000/svg" class="pikchr" width="250" height="51" viewbox="0 0 313.992 64.8"> <path d="M17,47L81,47A15 15 0 0 0 96 32A15 15 0 0 0 81 17L17,17A15 15 0 0 0 2 32A15 15 0 0 0 17 47Z" style="fill:none;stroke-width:2.16;stroke:#000"></path> <text x="49" y="32" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">username</text> <polygon points="124,32 113,36 113,28" style="fill:#000"></polygon> <path d="M96,32L119,32" style="fill:none;stroke-width:2.16;stroke:#000"></path> <path d="M124,47L204,47L204,17L124,17Z" style="fill:none;stroke-width:2.16;stroke:#000"></path> <text x="164" y="32" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">GetUser</text> <polygon points="233,17 221,21 221,12" style="fill:#add8e6"></polygon> <path d="M204,17L227,17" style="fill:none;stroke-width:2.16;stroke:#add8e6"></path> <path d="M248,32L296,32A15 15 0 0 0 311 17A15 15 0 0 0 296 2L248,2A15 15 0 0 0 233 17A15 15 0 0 0 248 32Z" style="fill:#add8e6;stroke-width:2.16;stroke:#000"></path> <text x="272" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">Success</text> <polygon points="233,47 221,51 221,43" style="fill:orange"></polygon> <path d="M204,47L227,47" style="fill:none;stroke-width:2.16;stroke:orange"></path> <path d="M248,62L290,62A15 15 0 0 0 305 47A15 15 0 0 0 290 32L248,32A15 15 0 0 0 233 47A15 15 0 0 0 248 62Z" style="fill:orange;stroke-width:2.16;stroke:#000"></path> <text x="269" y="47" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">Failure</text> </svg> </div> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-cs" data-lang="cs">(User OR Error) GetUser(<span class="hljs-built_in">string</span> username);</code></pre> </div> </div> <div class="paragraph"> <p>This sounds trivial, so why isn&#8217;t this done traditionally? At least part of that has to do with the fact C-like languages do not make it easy to do this. You would need to have a return type that can be <em>either</em> the success type <em>or</em> the failure type. In functional programming languages such a construct <em>does</em> exist and is called a <a href="https://en.wikipedia.org/wiki/Tagged_union">Discriminated Union</a>. But C-like languages, including C#, do not have support for such a type. Luckily C# has had added lots of language features over the years that make it possible to emulate discriminated unions and use them in a relatively convenient and type-safe way. In the next part of this article series we will have a look at one way of implementing explicit failure in C#: a <code>Result</code> type with two subtypes, the <code>Success</code> type for the success path and the <code>Failure</code> type for the failure path.</p> </div> </div> <div class="sect2"> <h3 id="_on_exception_throwing_and_catching">On exception throwing and catching</h3> <div class="paragraph"> <p>Making a failure path part of the function return type is neat, but it does not mean that there are no exceptional situations for which the exception throwing mechanism is a good fit. To give an extreme example, almost any function can <em>in theory</em> encounter an <code>OutOfMemoryException</code> while doing an allocation. Or any function could <em>in theory</em> trigger a bug somewhere causing a <code>NullReferenceException</code> to be thrown. Exceptions are a fact of life, and we should be prepared to deal with them. It would make no sense to have the returntype of each function indicate that it could return with a null reference failure in the way we suggested above. These cases are really exceptions which are <strong>unexpected</strong>. There is often no proper way to handle them other than to cancel the whole "operation", log the error and present the user with an appropriate error, indicating that something went completely sideways. So how should we deal with that in our code?</p> </div> <div class="arabic olist"> <ol class="arabic"> <li> <p>In a complex application there is no way of telling whether you have caught all exceptions you want to catch.</p> </li> <li> <p>You probably don&#8217;t want to crash your application or present your user an exception with a callstack.</p> </li> <li> <p>In that case you should split up your application into <a href="https://en.wikipedia.org/wiki/Fail-fast">fail-fast</a> modules.</p> <div class="ulist"> <ul> <li> <p>A piece of code is a valid fail-fast module if its abortion does not harm the health of the rest of the application.</p> </li> <li> <p>An fail-fast module may contain other fail-fast modules.</p> </li> </ul> </div> </li> <li> <p>Place a try-catch-all construction at the top of each fail-fast module, such that it is guaranteed that each exception will not propagate beyond the fail-fast module in which it occurs. Make sure the exception is properly handled and logged.</p> </li> <li> <p>Never place a try-catch construction at a point in your program where it incorrectly may prevent an fail-fast module to be aborted.</p> </li> <li> <p>The more fail-fast modules you have and the smaller they are, the more stable your application is expected to be.</p> </li> <li> <p>So, now we&#8217;ve achieved that an uncaught exception only affects its containing fail-fast module. However, we still don&#8217;t know if we&#8217;ve missed any exceptions that should <em>not</em> cause the fail-fast module to be aborted.</p> </li> <li> <p>Study any 3rd party APIs well for exceptions that could have been missed.</p> </li> <li> <p>Don&#8217;t throw exceptions yourself if it shouldn&#8217;t abort the fail-fast module. Instead make the corresponding failure part of the normal code path using a <code>Result</code> type.</p> </li> </ol> </div> <div class="paragraph"> <p>For example, in a web application each request should at least be a separate fail-fast module because a failure to handle a request should not bring the web application down or influence other requests in any other way. Some programs (perhaps a CLI) may consist of a single fail-fast module.</p> </div> </div> <div class="sect2"> <h3 id="_exception_throwing_vs_the_failure_type">Exception throwing vs the <code>Failure</code> type</h3> <div class="paragraph"> <p>When writing a function, a good way for deciding whether to propagate a failure by throwing an exception is by asking the following question.</p> </div> <div class="paragraph"> <p><em>Should the failure cause the entire fail-fast module to be aborted in any reasonably conceivable context in which the function might be called</em>?</p> </div> <div class="paragraph"> <p>If the answer is yes, then it is probably appropriate to handle the failure by throwing an exception. If the answer is no, then it is probably appropriate to handle the failure by incorporating it in the function return type.</p> </div> </div> </div> </div> </div> <div id="footer"> <div id="footer-text"> Last updated 2021-08-02 10:58:08 +0200 </div> </div> </body></html>